
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>三维变换中的矩阵 - 上古藏书阁</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    
    <meta name="description" content="扩充三维世界为了给诸多变换的实现扫清障碍，首先扩充三维世界的第四个分量，通常合并表示为xyzw
Point
Vector
点和向量的w分量我们知道点可以被平移而向量的平移并不改变其数学含义，w分量为,"> 
    <meta name="author" content="王泓泉"> 
    <link rel="alternative" href="atom.xml" title="上古藏书阁" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.jpg"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">上古藏书阁</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://culturecircle.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">三维变换中的矩阵</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">三维变换中的矩阵</h1>
        <div class="stuff">
            <span>六月 10, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/mathematics/" rel="tag">mathematics</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="扩充三维世界"><a href="#扩充三维世界" class="headerlink" title="扩充三维世界"></a>扩充三维世界</h1><p>为了给诸多变换的实现扫清障碍，首先扩充三维世界的第四个分量，通常合并表示为<em>xyzw</em></p>
<h2 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h2><p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%82%B9%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="点"></p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%90%91%E9%87%8F%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="向量"></p>
<h2 id="点和向量的w分量"><a href="#点和向量的w分量" class="headerlink" title="点和向量的w分量"></a>点和向量的<em>w</em>分量</h2><p>我们知道<strong>点</strong>可以被平移而<strong>向量</strong>的平移并不改变其数学含义，<em>w</em>分量为0、1时正体现了这样的区别。</p>
<p>在后文中，我们还将看到<em>w</em>分量的其他意义。</p>
<h1 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h1><p>矩阵变换大致有平移、缩放、旋转、投影几种。</p>
<p>要理解这些矩阵，首先我要告诉你的是：这一系列矩阵的根本来源是<strong>构造</strong>，先有需求，再有结果。请你暂时摒弃证明数学定理时的思维，我们不是要证明这些矩阵可以通过某种方式推导出来即其正确性，而是要<strong>构造出一种矩阵来解决需求</strong>。</p>
<h2 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h2><p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E7%A7%BB%E7%9F%A9%E9%98%B5.png" alt="平移矩阵"></p>
<p>顾名思义，平移矩阵的功能是平移一个点。平移简言之即给原坐标的各分量分别加一个偏移量，暂且用<img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/P%E7%82%B9.png" alt="P点">表示待变换的点，后文中若无说明也使用这个点。</p>
<p>需求已经明确了：将P点平移到<img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E7%A7%BB%E5%90%8E%E7%9A%84P%E7%82%B9.png" alt="平移后的P点"></p>
<p>即有以下等式：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E7%A7%BB%E5%B1%95%E5%BC%80%E5%BC%8F.png" alt="平移展开式"></p>
<p>其中<strong>T(0, 1)<strong>表示</strong>平移矩阵</strong>第<strong>0</strong>行第<strong>1</strong>列的值。</p>
<p>每一个方程有4个未知量，显然解不唯一，但是我们可以找出最简单的那个，所以就有了最初列出的平移矩阵。</p>
<p>我们来看平移过程的数学表示</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E7%A7%BB%E7%9F%A9%E9%98%B5%E5%BA%94%E7%94%A8.png" alt="平移矩阵应用"></p>
<p>根据矩阵运算法则，很轻易地可以得到预期结果。</p>
<p>平移矩阵逆矩阵的意义是反向平移，这个可以通过计算其逆矩阵得出：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E7%A7%BB%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86%E7%9F%A9%E9%98%B5.png" alt="平移矩阵的逆矩阵"></p>
<h2 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h2><p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5.png" alt="缩放矩阵"></p>
<p>有了先前的推导过程，缩放矩阵的来历更为直观，此处不再赘述。</p>
<p>通过计算得到缩放矩阵的逆矩阵</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5%E9%80%86%E7%9F%A9%E9%98%B5.png" alt="缩放矩阵逆矩阵"></p>
<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>旋转矩阵比上述两种要复杂一些，最终目的地是三维旋转矩阵，但是出发点是二维旋转矩阵。</p>
<h3 id="二维旋转"><a href="#二维旋转" class="headerlink" title="二维旋转"></a>二维旋转</h3><p>P点的参数方程</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/P%E7%82%B9%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B.png" alt="P点参数方程"></p>
<p>将P点按逆时针旋转Φ后P点坐标表示为</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/P%E7%82%B9%E6%97%8B%E8%BD%AC%E5%90%8E.png" alt="P点旋转后"></p>
<p>将上述过程表示以矩阵，有如下等式</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/P%E7%82%B9%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%BC%8F.png" alt="P点旋转矩阵式"></p>
<p>从此得出二维的旋转矩阵</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E4%BA%8C%E7%BB%B4%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5.png" alt="二维旋转矩阵"></p>
<h3 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h3><p>首先把三维旋转与先前推导的二维旋转联系起来，想两个问题：二维旋转是怎样推导的？现在还能不能这样推导？</p>
<p>三维旋转会保留坐标的其中一个分量不变。例如绕y轴旋转，则y坐标不变。（使用右手系）</p>
<p>看到这里，我们挑个好欺负的先来两下：在平面直角坐标系中将一个点绕z轴旋转Φ。</p>
<p>相比于二维旋转，x轴还是x轴，y轴也仍然是y轴，只是需要扩充一些数据来满足新的需求即不改变其z值。所以构造出以下矩阵</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%BB%95z%E8%BD%B4%E7%9A%84%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5.png" alt="绕z轴的旋转矩阵"></p>
<p>这个矩阵的推导可以说是水到渠成，那么能不能用类似的思维来推导绕另外两轴旋转的矩阵呢？</p>
<p>以绕x轴旋转为例。根据右手定则，绕x轴旋转时三维坐标系中的y轴等价于二维坐标系的x轴，而三维坐标系中的z轴等价于二维坐标系中的y轴，所以有以下结果</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E6%8E%A8%E5%AF%BC%E7%BB%95x%E8%BD%B4%E7%9A%84%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5.png" alt="推导绕x轴的旋转矩阵"></p>
<p>再结合不改变x坐标等要求有</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%BB%95x%E8%BD%B4%E7%9A%84%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5.png" alt="绕x轴的旋转矩阵"></p>
<p>同理有最后一个旋转矩阵</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%BB%95y%E8%BD%B4%E7%9A%84%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5.png" alt="绕y轴的旋转矩阵"></p>
<p>虽然旋转矩阵的推导和形式比平移矩阵或缩放矩阵更为复杂，但其逆矩阵比先前两者都要简单。</p>
<p>由于这三个旋转矩阵都是正交矩阵，所以其逆矩阵等于其转置矩阵，这在计算上节省了不少性能。旋转矩阵逆矩阵的几何意义也非常明确：反向旋转。</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E9%80%86%E7%9F%A9%E9%98%B5.png" alt="旋转矩阵逆矩阵"></p>
<p><strong>不论是二维或三维，上述矩阵的应用前提是目标单位处于坐标系原点，对于非原点坐标，需要先采用其他变换如平移将其变换至原点，旋转之后再复原。</strong></p>
<h2 id="绕任意轴的旋转矩阵"><a href="#绕任意轴的旋转矩阵" class="headerlink" title="绕任意轴的旋转矩阵"></a>绕任意轴的旋转矩阵</h2><p>旋转轴是用三维向量来表示的，我们要做的是以给出的旋转轴为基础建立一个新的三维坐标系，旋转轴即其轴之一。</p>
<p>现在已经有一轴，还需要再找出一轴，第三轴可由叉乘得出。</p>
<p>第二轴的寻找是有数学规律在其中的：将旋转轴绝对值最小的分量置为0，再交换剩下两分量，并将两分量中的第一个置负。</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC%E8%AE%A1%E7%AE%97%E5%B1%80%E9%83%A8%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="绕任意轴旋转计算局部坐标系"></p>
<p><strong>r</strong>是给定的任意旋转轴。</p>
<p>应用这个矩阵之后，在新的坐标系中，给定的旋转轴就是原<em>x</em>轴，计算的第二轴是原<em>y</em>轴，叉乘得出的为原<em>z</em>轴。所以接下来的旋转用绕<em>x</em>轴旋转的旋转矩阵即可，最后不要忘记反变换回去。</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC.png" alt="绕任意轴旋转"></p>
<h2 id="万向节锁"><a href="#万向节锁" class="headerlink" title="万向节锁"></a>万向节锁</h2><p>这种旋转也被称为欧拉变换，如果将绕*x(roll)，y(head)，z(pitch)*轴旋转的矩阵联结，我们会发现一个无法规避的问题：万向节锁（Gimbal Lock）</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E4%B8%89%E8%BD%B4%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E8%81%94%E7%BB%93.png" alt="三轴旋转矩阵联结"></p>
<p>当<code>cosp = 0</code>时，矩阵中的[2, 0]、[2, 2]两个值始终为0。显然其不该如此，因为这两个值是受<em>h、p</em>共同影响的。这就是万向节锁的根本原因。</p>
<p>如果你从未了解过万向节锁，可以去查阅一些相关资料，只是仅从动画层面来解释万向节锁多少有些难以理解。</p>
<p><em>顺便一提，在Unity中测试时发现不论模型的朝向如何，绕y轴转时始终是绕世界坐标系的y轴旋转，而非本地坐标系。</em></p>
<h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>投影是将一定范围内的对象映射到某一平面的过程。</p>
<p>投影矩阵并未某一特定矩阵，根据不同的需要可以有不同的投影策略。在图形学或游戏中，最常用的两种分别是正交投影和透视投影。</p>
<h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p>正交投影前后不改变两点之间的距离，平行线投影后仍然是平行线。所以，哪怕粗暴地将某个图元的某个坐标改为投影平面位置也称得上是一种正交投影。</p>
<p>正交投影矩阵通常用<code>(l, r, b, t, n, f)</code>6个标量来定义，分别代表<em>left, right, bottom, top, near, far</em>六个平面。在此<em>AABB Box</em>范围内的一切会被投影到某一平面，进入下一阶段的处理且有机会被渲染在显示器上，不过这是渲染管线的事儿了。</p>
<p><em>l, r, b ,t, n, f</em>定义的<em>box</em>接下来会被按照一定策略变换，不同的图形库有不同的策略，OpenGL最终将其变换成一个最小点为<code>(-1, -1, -1)</code>最大点为<code>(1, 1, 1)</code>的远平面，DirectX则是从<code>(-1, -1, 0)</code>到<code>(1, 1, 1)</code>的长方体。变换的方式是平移和缩放。</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5.png" alt="正交投影矩阵"></p>
<p>这是OpenGL中的正交投影矩阵<strong>雏形</strong>，平移矩阵的结果是将定义的<em>box</em>中心平移到原点，缩放矩阵则是将<em>box</em>的长宽高都变换为2（-1~1）。在几何上，将<code>(l, b, n)</code>变换到<code>(-1, -1, 1)</code>，将<code>(r, t, f)</code>变换到<code>(1, 1, -1)</code>，其内部的坐标也变换到了相应的位置。</p>
<p>注意这并不是最终应用的结果，由于OpenGL使用的右手系是面向负z轴的，所以从数字上来说，近平面的值要大于远平面，为了便于用户理解，还会进行一次对称变换，将其改为左手系使其迎合近平面值小远平面值大的习惯。</p>
<p>下面是手性变换时用到的矩阵，并不难理解：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%9D%90%E6%A0%87%E7%B3%BB%E6%89%8B%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="坐标系手性变换"></p>
<p>如之前所述，DirectX的策略并不相同（需要将z值映射到[0, 1]之间），但核心思想与OpenGL是一致的。</p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>与正交投影相比，透视投影后的平行线会在无穷远处相交，更复杂也更符合现实世界，我们的视觉就是透视投影。</p>
<p>透视投影范围的定义与正交投影有稍许不同，但同样是六个变量。可以想象现实场景，我们的可视范围不会是一个方体，而是一个四棱锥，最终目标仍然是要将这个可视体（平截头体）变换为位于原点的正方体（或长方体），如下图所示</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E6%88%AA%E5%A4%B4%E4%BD%93%E5%8F%98%E6%8D%A2%E4%B8%BA%E7%AB%8B%E6%96%B9%E4%BD%93.png" alt="平截头体变换为立方体"></p>
<p>现在要先将平截头体变换为一个方体，从而可以利用正交投影中的矩阵。</p>
<p>这个矩阵的来源同样是<strong>构造</strong>。</p>
<p>根据相似三角形</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E7%9B%B8%E4%BC%BC%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt="透视投影相似三角形"></p>
<p>平截头体内的一点会以如下方式变换：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E6%88%AA%E5%A4%B4%E4%BD%93%E5%86%85%E4%B8%80%E7%82%B9%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="平截头体内一点的变换"></p>
<p>而近平面上的点变换前后是一致的：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E8%BF%91%E5%B9%B3%E9%9D%A2%E7%82%B9%E7%9A%84%E5%8F%98%E6%8D%A2.png" alt="透视投影近平面点的变换"></p>
<p>结合以上要求，最终得到的压缩矩阵是：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E5%B9%B3%E6%88%AA%E5%A4%B4%E4%BD%93%E5%8F%98%E6%8D%A2%E4%B8%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E7%9F%A9%E9%98%B5.png" alt="平截头体变换为立方体矩阵"></p>
<p>将平截头体变换为方体之后，我们就回到了正交投影的轨道上，联结正交投影矩阵得到透视投影矩阵：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5.png" alt="透视投影矩阵"></p>
<p>同样要注意，这不是最终矩阵。</p>
<p>经过透视投影后图元的分布情况：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1z%E5%9D%90%E6%A0%87%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="透视投影z坐标分布图"></p>
<p>显然，当<code>near = 1</code>时靠近近平面一侧的z坐标分布非常疏，大部分坐标集中在<strong>远平面</strong>（相对熟悉OpenGL的读者别忘记手性转换）。</p>
<p>大部分时候数学库是通过<code>(fov, aspect, far, near)</code>四个参数来定义平截头体的，通过数学手段计算所需值代入即可。</p>
<h1 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h1><p>上述变换都是针对点而言的，如果直接应用在法线（向量）上，结果不如预期：</p>
<p><img src="http://blog-whq.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%9B%BE/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%95%B0%E5%AD%A6/%E6%B3%95%E7%BA%BF%E5%8F%98%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="法线变换示意图"></p>
<p>解决方法是计算变换矩阵的逆矩阵的转置。</p>
<blockquote>
<p>The transpose of the inverse can be used to transform normals. </p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><em>Real-Time Rendering 4th</em></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
